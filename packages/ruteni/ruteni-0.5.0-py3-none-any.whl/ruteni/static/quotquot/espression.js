class u extends SyntaxError{constructor(u,e,t,s){super(`${u} ${e[t]||""} at position ${t}`),this.description=u,this.expression=e,this.position=t,this.noMatch=!!s}}class e{constructor(u,e,t){this.e=u,this.rules=e,this.config=t,this.sp=!1,this.lt=!1,this.ch=0,this.i=0,this.branch="",this.level=0,this.nxtOp="",this.opPos=-1}rest(){return this.e.substr(this.i)}eof(){return this.i>=this.e.length}gb(u){u&&(this.sp=this.lt=!1,this.i+=u,this.ch=this.i)}err(e,t){throw new u(e||"Unexpected char",this.e,this.i,!!t)}teIdSt(u){const e=this.gtCh();return!!((u=Object.assign(Object.assign({},this.config.identStart),u)).re&&u.re.test(e)||this.gtCd()>=128&&(!u.re2||u.re2.test(e)))}teIdPt(u){const e=this.gtCh();return!!((u=Object.assign(Object.assign({},this.config.identPart),u)).re&&u.re.test(e)||this.gtCd()>=128&&(!u.re2||u.re2.test(e)))}gbCh(){return this.sp=this.lt=!1,this.ch=this.i+1,this.e.charAt(this.i++)}gtCh(u){return this.e.charAt(this.i+(u||0))}gtCd(u){return this.e.charCodeAt(this.i+(u||0))}tyCh(u){return u===this.e.charAt(this.i)&&(this.sp=this.lt=!1,this.i++,this.ch=this.i,!0)}gbSp(){let u=!1,e=!1;for(;!this.eof()&&((u=this.teSP())||(e=this.teLT()));)this.i++,this.sp=this.sp||u,this.lt=this.lt||e;return this.sp||this.lt}teSP(u){const e=this.gtCd(u);return 32===e||9===e}teLT(u){const e=this.gtCd(u);return 10===e||13===e}gbHex(u){let e,t=0,s=0;for(s=0;s<u&&!this.eof()&&(e="0123456789abcdef".indexOf(this.gtCh().toLowerCase()),e>=0);++s)this.i++,this.ch=this.i,t=16*t+e;return s!==u&&u!==1/0||!s?null:String.fromCodePoint(t)}gtOp(){if(this.nxtOp&&this.opPos===this.i)return this.nxtOp;const u=this.config.ops;let e=this.e.substr(this.i,this.config.maxOpLen),t=e.length;for(;t>0;){if(e in u&&(!u[e]||this.teSP(t)||this.teLT(t)||this.i+t>=this.e.length))return this.nxtOp=e,this.opPos=this.i,e;e=e.substr(0,--t)}return null}gbOp(u){this.gbSp();const e=this.gtOp();return e&&e in u?(this.gb(e.length),e):null}tySep(u){const e=this.gtCh();return!!u&&(e&&u.indexOf(e)>=0?(this.gbCh(),e):!!(this.sp&&u.indexOf(" ")>=0||(this.lt||this.eof())&&u.indexOf("\n")>=0)||u.indexOf("\0")>=0)}parseNext(u){const e=this.branch,t=this.level,s=this.i;let r;try{const i=this.moveRule(u);return r=i.pre(this)||this.parseNext(1),this.gbSp(),r=i.post(this,r),this.config.range&&!r.range&&(r.range=[s,this.ch]),r}finally{this.branch=e,this.level=t}}moveRule(u=0){if("string"==typeof u){if(!(u in this.rules))throw new Error(`No registered label ${u}`);this.branch=u,this.level=0}else 1===u&&this.level++;const e=this.rules[this.branch];if(this.level>=e.length)throw this.err("No matching rule",!0);const t=e[this.level];return"string"==typeof t?this.moveRule(t):t}parseMulti(u,e){const t=[];let s,r,i,n=0;do{this.gbSp(),i=this.i;try{if(r=this.parseNext(e),t[n]=r,s=this.tySep(u.separators),u.types&&u.types.indexOf(r.type)<0)return this.err(`Invalid argument type: ${r.type}`)}catch(e){if(!(e instanceof SyntaxError&&e.noMatch))throw e;if(s=this.tySep(u.separators),!s||!0===s){if(!u.trailling&&n>0)return this.err("Expected expression");n>0&&(s=!0);break}if(!u.sparse)return this.err("Expected expression");t[n]=!0!==u.sparse?u.sparse:null,this.config.range&&null!==t[n]&&(t[n].range=[i,this.eof()&&!this.lt?this.ch:this.i])}n++}while(s&&!this.eof()&&n<=u.maxSep);return s&&this.eof()&&!u.trailling?this.err("Expected expression"):((s&&!t.length||1===t.length&&(s||!u.separators)||t.length>1)&&(t.match=!0),t)}}class t{constructor(u,e,t,s,r){this.rules=u,this.startBranch=e,this.config={identStart:t||{re:/[$_A-Za-z]/},identPart:s||{re:/[$_0-9A-Za-z]/},maxOpLen:0,range:!!r,ops:{}};for(const e in u)u[e].forEach((u=>{if("string"==typeof u)return;const e=u.register();for(const u in e)u in this.config.ops||(this.config.ops[u]=!!e[u].space,this.config.maxOpLen=Math.max(this.config.maxOpLen,u.length))}))}parse(u){const t=new e(u,this.rules,this.config);t.gbSp();const s=t.parseNext(this.startBranch);return t.gbSp(),t.eof()?s:t.err()}}class s{constructor(){this.config={}}unwrapMulti(u){u.maxSep=u.separators?void 0===u.maxSep?1/0:u.maxSep:0}addExtra(u,e,t){return u.extra?"function"==typeof u.extra?u.extra(e,t):Object.assign(Object.assign({},u.extra),e):e}register(){return{}}pre(u){return null}post(u,e){return e}}
/*!
 * Copyright (c) 2018 Adrian Panella <ianchi74@outlook.com>
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */class r extends s{constructor(u){super(),this.config=u}pre(u){const e=[u.i,u.lt,u.sp];if(this.config.test&&!this.config.test.includes(u.gtCh()))return null;try{const e=u.parseNext(this.config.subRules);return this.addExtra(this.config,e,u)}catch(t){return[u.i,u.lt,u.sp]=e,null}}}class i extends s{constructor(u,e=!1){let t;super(),this.config=u,this.required=e;for(const e in u)t=u[e],t.empty=t.close&&t.empty||!1,t.separators=t.close&&t.separators||"",this.unwrapMulti(t)}register(){return this.config}post(u,e){const t=e.range?e.range[0]:u.i;let s=u.gbOp(this.config);if(this.required&&!s)return u.err(`Expected operator (${Object.keys(this.config).join(",")})`);for(;s;){const r=this.config[s];if(r.ltypes&&r.ltypes.indexOf(e.type)<0)return u.err("Invalid left-hand side");const i=u.parseMulti(r,r.subRules||(r.rasoc?0:1));if(!i.length&&!r.empty)return u.err("Expression expected.");if(delete i.match,r.close&&!u.tyCh(r.close))return u.err("Closing character expected. Found");e=this.addExtra(r,{type:r.type,[r.left||"left"]:e,[r.right||"right"]:r.separators?i:i[0]},u),r.oper&&(e[r.oper]=s),u.config.range&&(e.range=[t,u.ch]),s=r.rasoc?"":u.gbOp(this.config)}return e}}const n="BinaryExpression",o="LogicalExpression",a="AssignmentExpression",p="AssignmentPattern",l="ArrayPattern",A="ObjectPattern",c="Literal",h="TemplateLiteral",F="TemplateElement",C="TaggedTemplateExpression",g="Identifier",E="ThisExpression",B="ArrayExpression",D="ObjectExpression",d="MemberExpression",f="CallExpression",b="ConditionalExpression",x="SequenceExpression",y="UpdateExpression",m="UnaryExpression",w="NewExpression",O="ExpressionStatement",j="SpreadElement",v="RestElement",R="ArrowFunctionExpression",_="operator",P="prefix",k="object",S="property",L="expression",T="expressions",I="statement",q="nocomma_expr",$="token";function N(u,e,t){const s=e[u].findIndex((u=>u&&u.type===v));return s>=0&&s!==e[u].length-1&&t.err("rest element must be the last"),e}const M={type:n,oper:_},U=Object.assign(Object.assign({},M),{space:!0}),z={type:o,oper:_},Z={type:a,ltypes:["Identifier",d],oper:_,rasoc:!0,subRules:q},H={type:m,oper:_,prefix:"prefix"},G=Object.assign(Object.assign({},H),{isPre:!0}),J=Object.assign(Object.assign({},G),{space:!0}),K={type:y,oper:_,prefix:"prefix",types:["Identifier",d]},Q=Object.assign(Object.assign({},K),{isPre:!0}),V={type:B,prop:"elements",close:"]",separators:",",sparse:!0,trailling:!0,empty:!0,subRules:B},W={type:"params",prop:"params",close:")",separators:",",trailling:!0,empty:!0,subRules:"bindElem",extra:N.bind(null,"params")},X={type:l,close:"]",prop:"elements",isPre:!0,separators:",",sparse:!0,empty:!0,trailling:!0,subRules:l,extra:N.bind(null,"elements")},Y={type:"ObjectPattern",close:"}",prop:"properties",isPre:!0,separators:",",empty:!0,trailling:!0,subRules:"ObjectPattern",extra:(u,e)=>(u.properties=u.properties.map((u=>{const e="Identifier"!==u.type&&u.type!==p?u:{type:"Property",key:"Identifier"===u.type?u:u.left,value:u,kind:"init",method:!1,shorthand:!0,computed:!1};return u.range&&(e.range=u.range),e})),N("properties",u,e))},uu={type:"ObjectExpression",prop:"properties",close:"}",separators:",",trailling:!0,empty:!0,subRules:"object",types:["Identifier","Property",j],extra:u=>(u.properties=u.properties.map((u=>{const e="Identifier"!==u.type?u:{type:"Property",key:u,value:u,kind:"init",method:!1,shorthand:!0,computed:!1};return u.range&&(e.range=u.range),e})),u)},eu={type:"Property",left:"key",right:"value",extra:u=>Object.assign(Object.assign({},u),{key:u.key.type===L?u.key.argument:u.key,kind:"init",method:!1,shorthand:!1,computed:u.key.type===L}),subRules:q},tu={type:"SequenceExpression",prop:"expressions",separators:","},su={close:")",subRules:L},ru={type:d,left:"object",right:S,extra:{computed:!1},subRules:S},iu=Object.assign(Object.assign({},ru),{close:"]",extra:{computed:!0},subRules:L}),nu={type:f,left:"callee",right:"arguments",separators:",",close:")",empty:!0,subRules:q};function ou(u,e){const t={};Array.isArray(e)||(e=[e]),Array.isArray(u[0])||(u=[u]);for(let s=0;s<e.length;s++)for(let r=0;r<u[s].length;r++)t[u[s][r]]=e[s];return t}class au extends s{constructor(u){super(),this.config=u,u.prop=u.prop||L,this.unwrapMulti(u)}pre(u){const e=u.i,t=this.config,s=u.parseMulti(t,t.subRules||1);if(!s.match)return s.length?s[0]:null;if(delete s.match,!(s.length||t.empty&&t.separators))return u.err("Expression expected");const r=this.addExtra(t,{type:t.type,[t.prop]:t.separators?s:s[0]},u);return u.config.range&&(r.range=[e,u.eof()&&!u.lt?u.ch:u.i]),r}}class pu extends s{constructor(u){super(),this.config=Object.assign({firstOp:"?",secondOp:":"},u)}post(u,e){const t=this.config;if(u.gbSp(),!u.tyCh(t.firstOp))return e;const s=u.parseNext(t.subRules||0);if(u.gbSp(),!u.tyCh(t.secondOp))return u.err(`Operator ${t.secondOp} expected, but found`);const r=u.parseNext(t.subRules||0);return this.addExtra(t,{type:t.type,[t.first||"test"]:e,[t.middle||"consequent"]:s,[t.last||"alternate"]:r},u)}}class lu extends s{constructor(u){let e;super(),this.config=u,this.preConf={},this.postConf={};for(const t in u)e=u[t],e.close?e.isPre=!0:e.separators=e.empty=void 0,this.unwrapMulti(e),e.isPre?this.preConf[t]=u[t]:this.postConf[t]=u[t]}register(){return this.config}pre(u){const e=u.gbOp(this.preConf);if(!e)return null;const t=this.preConf[e],s=u.parseMulti(t,t.subRules||0);return s.length||t.empty?(delete s.match,t.close&&!u.tyCh(t.close)?u.err("Closing character expected. Found"):this.makeNode(e,!t.separators&&s.length&&s[0]?s[0]:s,u)):u.err("Expression expected.")}post(u,e){const t=this.postConf;let s=null;return u.lt||(s=u.gbOp(t)),s?t[s].types&&t[s].types.indexOf(e.type)<0?u.err(`Invalid argument type: ${e.type}`):this.makeNode(s,e,u):e}makeNode(u,e,t){const s=this.config[u],r=s.type?{type:s.type,[s.prop||"argument"]:e}:e;return s.oper&&(r[s.oper]=u),s.prefix&&(r[s.prefix]=!!s.isPre),this.addExtra(s,r,t)}}class Au extends s{constructor(u){super(),this.config=u||{}}pre(u){const e=this.config;let t;if(!u.teIdSt(e.identStart))return null;for(t=u.gbCh();!u.eof()&&u.teIdPt(e.identPart);)t+=u.gbCh();return e.this&&"this"===t?{type:"ThisExpression"}:e.literals&&t in e.literals?{type:e.typeLiteral||"Literal",[e.propLiteral||"value"]:e.literals[t],raw:t}:e.reserved&&e.reserved.indexOf(t)>=0?u.err("Invalid reserved identifier"):{type:e.typeIdent||"Identifier",[e.propIdent||"name"]:t}}}class cu extends s{constructor(u={radix:10,decimal:!0,exp:!0}){if(super(),this.config=u,u.radix<2||u.radix>36)throw new RangeError("Radix out of range");let e="0-"+(u.radix<10?u.radix-1:9);u.radix>10&&(e+=`A-${String.fromCharCode(64+u.radix-10)}`),10!==u.radix&&(u.decimal=!1,u.exp=!1),this.digits=new RegExp(`[${e}]`,"i"),u.prefix&&(this.prefix=new RegExp(`^${u.prefix}`,"i"))}pre(u){const e=this.config;let t,s="",r="";if(this.prefix){const e=this.prefix.exec(u.rest());if(!e)return null;r=e[0],u.gb(r.length)}for(;this.digits.test(u.gtCh());)s+=u.gbCh();if(e.decimal&&"."===u.gtCh())for(s+=u.gbCh();this.digits.test(u.gtCh());)s+=u.gbCh();if(!(s&&"."!==s||r))return u.gb(-s.length),null;if(t=u.gtCh(),e.exp&&("e"===t||"E"===t)){for(s+=u.gbCh(),t=u.gtCh(),"+"!==t&&"-"!==t||(s+=u.gbCh());this.digits.test(u.gtCh());)s+=u.gbCh();this.digits.test(u.gtCh(-1))||u.err(`Expected exponent (${s}${u.gtCh()})`)}return s.length?u.teIdSt()?u.err():{type:"Literal",value:e.decimal?parseFloat(s):parseInt(s,e.radix),raw:r+s}:u.err("Invalid number format")}}class hu extends s{constructor(u={}){super(),u.flags=u.flags||"gimuy",this.config=u}pre(u){const e=u.i;if(!u.tyCh("/"))return null;let t,s,r="",i=!1,n=!1,o="";for(;!u.eof();)if(r+=t=u.gbCh(),"\\"===t){if(u.teLT())return u.err("Unterminated Regular Expression");r+=u.gbCh()}else{if(u.teLT())return u.err("Unterminated Regular Expression");if(i)"]"===t&&(i=!1);else{if("/"===t){n=!0;break}"["===t&&(i=!0)}}if(!n)return u.err("Unterminated Regular Expression");for(r=r.substr(0,r.length-1);!u.eof()&&this.config.flags&&this.config.flags.indexOf(u.gtCh())>=0;)o+=u.gbCh();try{s=new RegExp(r,o)}catch(e){return u.err(e.message)}return{type:"Literal",value:s,raw:u.e.substring(e,u.i),regex:{pattern:r,flags:o}}}}class Fu extends s{constructor(u={LT:!0,hex:!0,raw:!0}){super(),this.config=u}pre(u){const e=this.config;let t,s=!1,r="",i=!1===e.unquoted&&e.templateRules?"`":"",n=!1,o=u.i,a=!1,p=e.LT;const l=[],A=[],c=[];if(void 0===e.unquoted){if(t=u.gtCh(),e.templateRules&&"`"===t)a=!0,p=!0,o++;else if('"'!==t&&"'"!==t)return null;i=u.gbCh()}else e.templateRules&&(a=!0,p=!0);for(;!u.eof();){if(t=u.gbCh(),t===i){n=!0,a&&A.push(Object.assign({type:"TemplateElement",value:{cooked:r,raw:u.e.substring(o,u.i-1)},tail:!0},u.config.range?{range:[o,u.i-1]}:{}));break}if(a&&"$"===t&&u.tyCh("{")){if(A.push(Object.assign({type:"TemplateElement",value:{cooked:r,raw:u.e.substring(o,u.i-2)},tail:!1},u.config.range?{range:[o,u.i-2]}:{})),r="",l.push(u.parseNext(e.templateRules)),u.gbSp(),!u.tyCh("}"))return u.err('Expected "}" but found ');o=u.i}else if("\\"===t){const i=u.i-1;if(p&&u.teLT())t=u.gbCh(),"\r"===t&&u.tyCh("\n");else switch(t=u.gbCh(),t){case"n":r+="\n";break;case"r":r+="\r";break;case"t":r+="\t";break;case"b":r+="\b";break;case"f":r+="\f";break;case"v":r+="\v";break;case"u":case"x":if(e.hex){if(e.cp&&(s=u.tyCh("{")),t=u.gbHex(s?1/0:"u"===t?4:2),null===t)return u.err("Hexadecimal digit expected");if(s&&!u.tyCh("}"))return u.err("Closing } expected");s=!1}r+=t;break;default:r+=t}c.push({offset:i,length:u.i-i})}else if(e.LT&&u.teLT(-1)){if(!a)return u.err("Invalid line terminator in string");"\r"===t&&u.tyCh("\n"),r+="\n"}else r+=t}if(n||e.unquoted||u.err("Unclosed quote after "),a)return{type:"TemplateLiteral",quasis:A,expressions:l};const h={type:"Literal",value:r,raw:e.raw?u.e.substring(o,u.i):i+r+i};return e.escapes&&(h.escapes=c),h}}function Cu(u,e){let t=0;if(!u||!u.escapes||"Literal"!==u.type)return e;for(const s of u.escapes){if(!(s.offset<e+t))break;t+=s.length-1}return e+t}const gu={re:/[$_A-Za-z]/,re2:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},Eu={re:/[$_0-9A-Za-z]/,re2:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/};function Bu(u,e){return{identStart:u,identPart:e,literals:{true:!0,false:!1,null:null},this:!0}}const Du={type:"Program",prop:"body",extra:{sourceType:"script"},separators:";\n",sparse:{type:"EmptyStatement"},trailling:!0,empty:!0},du=[{"||":z},{"&&":z}],fu=[{"|":M},{"^":M},{"&":M},ou(["==","!=","===","!=="],M),ou([["<",">","<=",">="],["instanceof","in"]],[M,U]),ou(["<<",">>",">>>"],M),ou(["+","-"],M),ou(["*","/","%"],M)],bu=[new cu({radix:16,prefix:"0x"}),new cu({radix:8,prefix:"0o"}),new cu({radix:2,prefix:"0b"}),new cu],xu=new i({".":ru,"[":iu});function yu(u,e){const t=new Au(Bu(u,e)),s=bu.concat([new Fu({LT:!0,hex:!0,cp:!0,raw:!0,templateRules:L}),t,new lu({"[":V}),new hu,new lu({"{":uu})]),r=new lu({new:{type:w,prop:"callee",isPre:!0,space:!0,subRules:w,extra:u=>(u.callee.type!==f?u.arguments=[]:(u.arguments=u.callee.arguments,u.callee=u.callee.callee),u)}}),a=new lu({"(":su}),p=new Au({identStart:u,identPart:e});return{statement:[new au(Du),new au({type:"ExpressionStatement",prop:L,extra:u=>"Literal"===u.expression.type&&"string"==typeof u.expression.value?Object.assign(Object.assign({},u),{directive:u.expression.raw.substring(1,u.expression.raw.length-1)}):u}),L],[L]:[new au(tu),q],[q]:[new i(ou(["=","+=","-=","*=","/=","%=",">>=","<<=",">>>=","|=","&=","^="],Z)),new pu({type:"ConditionalExpression",subRules:q}),o],[o]:[...du.map((u=>new i(u))),n],[n]:[...fu.map((u=>new i(u))),m],[m]:[new lu(ou([["+","-","!","~"],["typeof","void","delete"]],[G,J])),y],[y]:[new lu(ou(["++","--"],Q)),new lu(ou(["++","--"],K)),d],[d]:[new i({".":ru,"[":iu,"(":nu,"`":{type:C,left:"tag",right:"quasi",subRules:"template"}}),r,a,"token"],token:s,[S]:[p],[w]:[r,new i({"(":nu}),xu,a,"token"],object:[new i({":":eu}),new lu({"[":{type:L,close:"]",subRules:q}}),...bu,p,new Fu({LT:!0,hex:!0,raw:!0})],[B]:[new lu({"...":{type:j,isPre:!0,subRules:q}}),q],template:[new Fu({LT:!0,hex:!0,raw:!0,unquoted:!1,templateRules:L})],lvalue:[xu,t]}}class mu extends t{constructor(u,e,t,s){super(yu(e,t),u?L:"statement",e,t,s)}}
/*!
 * Copyright (c) 2018 Adrian Panella <ianchi74@outlook.com>
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */function wu(u,e){const t=new lu({"[":X,"{":Y}),s=new lu({"[":Object.assign(Object.assign({},X),{subRules:"ArrayBind"}),"{":Object.assign(Object.assign({},Y),{subRules:"ObjectBind"})}),n=Object.assign(Object.assign({},yu(u,e)),{bindElem:[new lu({"...":{type:v,isPre:!0,subRules:S}}),new i({"=":{type:p,subRules:q}}),s,S],destructuringAssignement:[new i({"=":Object.assign(Object.assign({},Z),{ltypes:void 0})},!0),t],ObjectPattern:[new lu({"...":{type:v,isPre:!0,subRules:S}}),new r({subRules:"property_with_target"}),new i({"=":{type:p,subRules:q}}),xu,S],ObjectBind:[new lu({"...":{type:v,isPre:!0,subRules:S}}),new r({subRules:"property_with_target_bind"}),new i({"=":{type:p,subRules:q}}),S],property_with_target:[new i({":":Object.assign(Object.assign({},eu),{subRules:"property_target"})},!0),new lu({"[":{type:L,close:"]",subRules:q}}),...bu,new Fu({LT:!0,hex:!0,raw:!0}),S],property_target:[new i({"=":{type:p,subRules:q}}),t,xu,S],property_with_target_bind:[new i({":":Object.assign(Object.assign({},eu),{subRules:"property_target_bind"})},!0),new lu({"[":{type:L,close:"]",subRules:q}}),...bu,new Fu({LT:!0,hex:!0,raw:!0}),S],property_target_bind:[new i({"=":{type:p,subRules:q}}),s,S],[l]:[new lu({"...":{type:v,isPre:!0,subRules:S}}),new i({"=":{type:p,subRules:q}}),xu,t,S],ArrayBind:[new lu({"...":{type:v,isPre:!0,subRules:S}}),new i({"=":{type:p,subRules:q}}),s,S],arrow:[new i({"=>":{type:"ArrowFunctionExpression",subRules:q,right:"body",left:"params",extra:u=>(u.params="params"!==u.params.type?[u.params]:u.params.params,Object.assign(Object.assign({},u),{id:null,generator:!1,expression:!0,async:!1}))}},!0),new lu({"(":W}),S]});return n.nocomma_expr.splice(1,0,new r({subRules:"arrow"})),n.nocomma_expr.splice(0,0,new r({subRules:"destructuringAssignement",test:"[{"})),n}class Ou extends t{constructor(u,e,t,s){super(wu(e,t),u?L:"statement",e,t,s)}}
/*!
 * Copyright (c) 2020 Adrian Panella <ianchi74@outlook.com>
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */function ju(u,e){const t=nu.trailling;nu.trailling=!0;const s=Object.assign(Object.assign({},wu(u,e)),{Exponential:[new r({subRules:"ParentesisExponential",test:"("}),new i({"**":Object.assign(Object.assign({},M),{subRules:"Exponential",extra:u=>{if(u.left.type===m)throw new Error("Unary operator used immediately before exponentiation expression.");return u}})}),m],ParentesisExponential:[new i({"**":Object.assign(Object.assign({},M),{subRules:"Exponential",type:n})},!0),new lu({"(":su})],Nullish:[new i({"??":z},!0),n],ParentesisOptChain:[new i({"?.":Object.assign(Object.assign({},ru),{extra:{computed:!1,optional:!0,shortCircuited:!1}}),"?.[":Object.assign(Object.assign({},iu),{extra:{computed:!0,optional:!0,shortCircuited:!1}}),"?.(":Object.assign(Object.assign({},nu),{extra:{optional:!0,shortCircuited:!1}}),".":Object.assign(Object.assign({},ru),{extra:{computed:!1,optional:!1,shortCircuited:!1}}),"[":Object.assign(Object.assign({},iu),{extra:{computed:!0,optional:!1,shortCircuited:!1}}),"(":Object.assign(Object.assign({},nu),{extra:{optional:!1,shortCircuited:!1}}),"`":{type:C,left:"tag",right:"quasi",subRules:"template",extra:{optional:!1,shortCircuited:!1}}},!0),new lu({"(":su})]});return s.nocomma_expr[1]=new i(ou(["=","+=","-=","*=","/=","%=",">>=","<<=",">>>=","|=","&=","^=","**="],Z)),s[n].splice(-1,1,"Exponential"),s.object.splice(0,0,new lu({"...":{type:j,isPre:!0,subRules:q}})),s[o].splice(0,0,new r({subRules:"Nullish"})),s[d].splice(0,1,new i({"?.":Object.assign(Object.assign({},ru),{extra:u=>Object.assign(Object.assign({},u),{computed:!1,optional:!0,shortCircuited:!(!u.object||!u.object.shortCircuited&&!u.object.optional)})}),"?.[":Object.assign(Object.assign({},iu),{extra:u=>Object.assign(Object.assign({},u),{computed:!0,optional:!0,shortCircuited:!(!u.object||!u.object.shortCircuited&&!u.object.optional)})}),"?.(":Object.assign(Object.assign({},nu),{extra:u=>Object.assign(Object.assign({},u),{optional:!0,shortCircuited:!(!u.callee||!u.callee.shortCircuited&&!u.callee.optional)})}),".":Object.assign(Object.assign({},ru),{extra:u=>Object.assign(Object.assign({},u),{computed:!1,optional:!1,shortCircuited:!(!u.object||!u.object.shortCircuited&&!u.object.optional)})}),"[":Object.assign(Object.assign({},iu),{extra:u=>Object.assign(Object.assign({},u),{computed:!0,optional:!1,shortCircuited:!(!u.object||!u.object.shortCircuited&&!u.object.optional)})}),"(":Object.assign(Object.assign({},nu),{extra:u=>Object.assign(Object.assign({},u),{optional:!1,shortCircuited:!(!u.callee||!u.callee.shortCircuited&&!u.callee.optional)})}),"`":{type:C,left:"tag",right:"quasi",subRules:"template",extra:(u,e)=>{if(u.tag&&(u.tag.shortCircuited||u.tag.optional))throw e.err("Invalid tagged template on optional chain");return Object.assign(Object.assign({},u),{optional:!1,shortCircuited:!1})}}}),new r({subRules:"ParentesisOptChain",test:"("})),nu.trailling=t,s}class vu extends t{constructor(u,e,t,s){super(ju(e,t),u?L:"statement",e,t,s)}}const Ru={type:"Compound",prop:"body",separators:",; \n\0",sparse:!0,trailling:!0,empty:!0,extra:u=>(u.body=u.body.filter((u=>u)),1===u.body.length?u.body[0]:u)},_u=[{"||":z},{"&&":z},{"|":M},{"^":M},{"&":M},ou(["==","!=","===","!=="],M),ou(["<",">","<=",">="],U),ou(["<<",">>",">>>"],M),ou(["+","-"],M),ou(["*","/","%"],M)];function Pu(){return{statement:[new au(Ru),L],[L]:[q],[q]:[new pu({type:"ConditionalExpression"}),..._u.map((u=>new i(u))),new lu(ou(["+","-","!","~"],G)),new i({".":ru,"[":iu,"(":nu}),new lu({"(":su}),"token"],token:[new Fu({LT:!1,hex:!1,raw:!1}),new cu,new Au(Bu()),new lu({"[":Object.assign(Object.assign({},V),{subRules:q})})],[S]:[new Au({this:!0})]}}class ku extends t{constructor(){super(Pu(),"statement")}}class Su{evaluate(u,e){return this._eval(u,e||{})}_eval(u,e){try{if(!(u.type in this))throw new Error(`Unsupported expression type: ${u.type}`);return this[u.type](u,e)}catch(e){throw e.node||(e.node=u),e}}_resolve(u,e,t,...s){return t(...s.map((e=>e?this._eval(e,u):void 0)))}}function Lu(u,e){return new Error(`Unsuported ${u}: ${e}`)}const Tu={"|":(u,e)=>u|e,"^":(u,e)=>u^e,"&":(u,e)=>u&e,"==":(u,e)=>u==e,"!=":(u,e)=>u!=e,"===":(u,e)=>u===e,"!==":(u,e)=>u!==e,"<":(u,e)=>u<e,">":(u,e)=>u>e,"<=":(u,e)=>u<=e,">=":(u,e)=>u>=e,instanceof:(u,e)=>u instanceof e,in:(u,e)=>u in e,"<<":(u,e)=>u<<e,">>":(u,e)=>u>>e,">>>":(u,e)=>u>>>e,"+":(u,e)=>u+e,"-":(u,e)=>u-e,"*":(u,e)=>u*e,"/":(u,e)=>u/e,"%":(u,e)=>u%e,"**":(u,e)=>u**e},Iu={"-":u=>-u,"+":u=>+u,"!":u=>!u,"~":u=>~u,typeof:u=>typeof u,void:u=>{}},qu=0,$u=1,Nu=2;class Mu extends Su{lvalue(u,e){return{o:{},m:""}}Literal(u){return u.value}Identifier(u,e){return e[u.name]}ThisExpression(u,e){return e}ArrayExpression(u,e){return this._resolve(e,0,((...u)=>u),...u.elements)}MemberExpression(u,e){return this._member(u,e,(u=>u&&u.o[u.m]))}_MemberObject(u,e){return this._member(u,e,(u=>u))}_member(u,e,t){const s=u.optional||u.shortCircuited;return this._resolve(e,s?3:2,((r,i)=>s?null==r?t(void 0):u.computed?this._resolve(e,0,(u=>t({o:r,m:u})),u.property):t({o:r,m:u.property.name}):t({o:r,m:u.computed?i:u.property.name})),u.object,s||!u.computed?void 0:u.property)}CallExpression(u,e){const t=u.optional||u.shortCircuited,s=(s,r,i)=>{if(!t||null!=r){if("function"!=typeof r)throw new TypeError("Callee is not a function");return t?this._resolve(e,0,((...u)=>r.apply(s,u)),...u.arguments):r.apply(s,i)}};return this._resolve(e,1,((t,...r)=>u.callee.type===d?s(null==t?void 0:t.o,null==t?void 0:t.o[t.m],r):s(e,t,r)),u.callee.type===d?Object.assign(Object.assign({},u.callee),{type:"_MemberObject"}):u.callee,...t?[]:u.arguments)}ConditionalExpression(u,e){return this._resolve(e,1,(t=>this._eval(t?u.consequent:u.alternate,e)),u.test)}SequenceExpression(u,e){return this._resolve(e,0,((...u)=>u.pop()),...u.expressions)}LogicalExpression(u,e){return this._resolve(e,1,(t=>{switch(u.operator){case"||":return t||this._eval(u.right,e);case"&&":return t&&this._eval(u.right,e);case"??":return null!=t?t:this._eval(u.right,e);case"##":return this._eval(u.right,e);default:throw Lu(n,u.operator)}}),u.left)}BinaryExpression(u,e){if(!(u.operator in Tu))throw Lu(n,u.operator);return this._resolve(e,0,Tu[u.operator],u.left,u.right)}UnaryExpression(u,e){if(!(u.operator in Iu))throw Lu(m,u.operator);return this._resolve(e,0,Iu[u.operator],u.argument)}ExpressionStatement(u,e){return this._eval(u.expression,e)}Program(u,e){return this._resolve(e,0,((...u)=>u.pop()),...u.body)}Compound(u,e){return this.Program(u,e)}}const Uu={"=":(u,e,t)=>u[e]=t,"+=":(u,e,t)=>u[e]+=t,"-=":(u,e,t)=>u[e]-=t,"*=":(u,e,t)=>u[e]*=t,"/=":(u,e,t)=>u[e]/=t,"%=":(u,e,t)=>u[e]%=t,"**=":(u,e,t)=>u[e]**=t,"<<=":(u,e,t)=>u[e]<<=t,">>=":(u,e,t)=>u[e]>>=t,">>>=":(u,e,t)=>u[e]>>>=t,"|=":(u,e,t)=>u[e]|=t,"&=":(u,e,t)=>u[e]&=t,"^=":(u,e,t)=>u[e]^=t},zu={"++":(u,e)=>++u[e],"--":(u,e)=>--u[e]},Zu={"++":(u,e)=>u[e]++,"--":(u,e)=>u[e]--};class Hu extends Mu{lvalue(u,e){let t;switch(u.type){case"Identifier":return{o:e,m:u.name};case d:if(t=this._MemberObject(u,e),!t)throw new Error("Invalid left side expression");return t;default:throw new Error("Invalid left side expression")}}ArrayExpression(u,e){return this._resolve(e,0,((...e)=>{const t=[];return u.elements.forEach(((u,s)=>{if(u&&u.type===j)for(const u of e[s])t.push(u);else u?t.push(e[s]):t.length++})),t}),...u.elements.map((u=>(null==u?void 0:u.type)===j?u.argument:u)))}ObjectExpression(u,e){const t=[],s=[],r=[],i=[],n=u.properties.map(((u,e)=>{let n;if(u.type===j)return t.push(void 0),i.push(e),u.argument;if(u.computed)t.push(void 0),r.push(e),s.push(u.key);else{if("Identifier"===u.key.type)n=u.key.name;else{if("Literal"!==u.key.type)throw new Error("Invalid property");n=u.key.value.toString()}t.push(n)}return u.value}));return this._resolve(e,0,((...u)=>(r.forEach((e=>t[e]=u.shift())),u.reduce(((u,e,s)=>(i.indexOf(s)>=0?Object.keys(null!=e?e:{}).forEach((t=>u[t]=e[t])):u[t[s]]=e,u)),{}))),...s,...n)}TemplateLiteral(u,e){return this._resolve(e,0,((...e)=>e.reduce(((e,t,s)=>e+(t+u.quasis[s+1].value.cooked)),u.quasis[0].value.cooked)),...u.expressions)}TaggedTemplateExpression(u,e){return this.CallExpression({type:f,callee:u.tag,optional:u.optional,shortCircuited:u.shortCircuited,arguments:[{type:"ArrayExpression",elements:u.quasi.quasis},...u.quasi.expressions]},e)}TemplateElement(u,e){return u.value.cooked}_assignPattern(u,e,t,s,r){switch(u.type){case l:if("="!==e)throw new Error("Invalid left-hand side in assignment");if(!Array.isArray(t))throw new Error("TypeError: must be array");for(let i=0;i<u.elements.length;i++)u.elements[i]&&(u.elements[i].type===v?this._assignPattern(u.elements[i].argument,e,t.slice(i),s,r):this._assignPattern(u.elements[i],e,t[i],s,r));break;case"ObjectPattern":if("="!==e)throw new Error("Invalid left-hand side in assignment");if(null==t)throw new Error("TypeError: must be convertible to object");const i={};for(let n=0;n<u.properties.length;n++)if(u.properties[n].type===v){const o=Object.keys(t).filter((u=>!(u in i))).reduce(((u,e)=>(u[e]=t[e],u)),{});this._assignPattern(u.properties[n].argument,e,o,s,r)}else{const o=u.properties[n].computed?this._eval(u.properties[n].key,s):"Literal"===u.properties[n].key.type?u.properties[n].key.value:u.properties[n].key.name;i[o]=!0,this._assignPattern(u.properties[n].value,e,t[o],s,r)}break;case"AssignmentPattern":return void 0===t&&(t=this._eval(u.right,null!=r?r:s)),this._assignPattern(u.left,e,t,s,r);default:const n=this.lvalue(u,s);return Uu[e](n.o,n.m,t)}return t}AssignmentExpression(u,e){if(!(u.operator in Uu))throw Lu(a,u.operator);const t=this._eval(u.right,e);return this._assignPattern(u.left,u.operator,t,e)}UpdateExpression(u,e){const t=u.prefix?zu:Zu;if(!(u.operator in t))throw Lu(y,u.operator);const s=this.lvalue(u.argument,e);return t[u.operator](s.o,s.m)}UnaryExpression(u,e){if("delete"===u.operator){const t=this.lvalue(u.argument,e);return delete t.o[t.m]}return super.UnaryExpression(u,e)}NewExpression(u,e){return this._resolve(e,0,((u,...e)=>new u(...e)),u.callee,...u.arguments)}}
/*!
 * Copyright (c) 2018 Adrian Panella <ianchi74@outlook.com>
 *
 * This software is released under the MIT License.
 * https://opensource.org/licenses/MIT
 */class Gu extends Hu{ArrowFunctionExpression(u,e){return(...t)=>{const s=Object.create(e);return this._assignPattern({type:l,elements:u.params},"=",t,s,e),this._eval(u.body,s)}}}export{B as ARRAY_EXP,l as ARRAY_PAT,X as ARRAY_PAT_TYPE,V as ARRAY_TYPE,R as ARROW_EXP,a as ASSIGN_EXP,p as ASSIGN_PAT,Z as ASSIGN_TYPE,n as BINARY_EXP,M as BINARY_TYPE,U as BINARY_TYPE_SP,s as BaseRule,Mu as BasicEval,ku as BasicParser,i as BinaryOperatorRule,f as CALL_EXP,nu as CALL_TYPE,tu as COMMA_TYPE,b as CONDITIONAL_EXP,mu as ES5Parser,Hu as ES5StaticEval,Ou as ES6Parser,Gu as ES6StaticEval,Gu as ESNextStaticEval,vu as ESnextParser,L as EXPRESSION,T as EXPRESSIONS,O as EXPRESSION_EXP,su as GROUP_TYPE,g as IDENTIFIER_EXP,Au as IdentifierRule,c as LITERAL_EXP,o as LOGICAL_EXP,z as LOGICAL_TYPE,d as MEMBER_EXP,ru as MEMBER_TYPE,iu as MEMBER_TYPE_COMP,au as MultiOperatorRule,w as NEW_EXP,q as NOCOMMA_EXPR,cu as NumberRule,k as OBJECT,D as OBJECT_EXP,A as OBJECT_PAT,Y as OBJECT_PAT_TYPE,uu as OBJECT_TYPE,_ as OPER,W as PARAMS_TYPE,P as PREFIX,S as PROPERTY,eu as PROPERTY_TYPE,u as ParseError,t as Parser,e as ParserContext,Nu as RESOLVE_MEMBER,qu as RESOLVE_NORMAL,$u as RESOLVE_SHORT_CIRCUITED,v as REST_ELE,hu as RegexRule,x as SEQUENCE_EXP,j as SPREAD_EXP,I as STATEMENT,Su as StaticEval,Fu as StringRule,C as TAGGED_EXP,F as TEMPLATE_ELE,h as TEMPLATE_EXP,E as THIS_EXP,$ as TOKEN,pu as TernaryOperatorRule,r as TryBranchRule,m as UNARY_EXP,H as UNARY_TYPE,G as UNARY_TYPE_PRE,J as UNARY_TYPE_PRE_SP,y as UPDATE_EXP,K as UPDATE_TYPE,Q as UPDATE_TYPE_PRE,lu as UnaryOperatorRule,Uu as assignOpCB,Pu as basicRules,Tu as binaryOpCB,N as checkRest,Eu as es5IdentPart,gu as es5IdentStart,yu as es5Rules,wu as es6Rules,ju as esNextRules,ou as opConf,Zu as postUpdateOpCB,zu as preUpdateOpCB,Cu as toRawPosition,Iu as unaryOpCB,Lu as unsuportedError};
