# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pylint: disable=all
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
import sys
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Callable,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)

if sys.version_info >= (3, 9):
    from typing import TypedDict, Literal
else:
    from typing_extensions import TypedDict, Literal

# -- template builder.py.jinja --
from . import types, errors
from ._types import BaseModelT


if TYPE_CHECKING:
    from .client import Client



class PostActions(Generic[BaseModelT]):
    def __init__(self, client: 'Client', model: Type[BaseModelT]) -> None:
        self._client = client
        self._model = model

    async def create(
        self,
        data: types.PostCreateInput,
        include: Optional[types.PostInclude] = None
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='Post',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='Post',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='Post',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='Post',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
    ) -> List[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='Post',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        include: Optional[types.PostInclude] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='Post',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.PostUpdateInput,
        where: types.PostWhereUniqueInput,
        include: Optional[types.PostInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='Post',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.PostWhereUniqueInput,
        data: types.PostUpsertInput,
        include: Optional[types.PostInclude] = None,
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='Post',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.PostUpdateManyMutationInput,
        where: types.PostWhereInput,
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='Post',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def count(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PostWhereInput] = None,
        cursor: Optional[types.PostWhereUniqueInput] = None,
        order: Optional[Union[types.PostOrderByInput, List[types.PostOrderByInput]]] = None,
    ) -> int:
        # TODO: support select
        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='Post',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
            },
            root_selection=['count { _all }'],
        )
        return cast(int, resp['data']['result']['count']['_all'])

    async def delete_many(
        self,
        where: Optional[types.PostWhereInput] = None
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='Post',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])


class UserActions(Generic[BaseModelT]):
    def __init__(self, client: 'Client', model: Type[BaseModelT]) -> None:
        self._client = client
        self._model = model

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='User',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='User',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='User',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='User',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
    ) -> List[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='User',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='User',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='User',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='User',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='User',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def count(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
    ) -> int:
        # TODO: support select
        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='User',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
            },
            root_selection=['count { _all }'],
        )
        return cast(int, resp['data']['result']['count']['_all'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='User',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])


class CategoryActions(Generic[BaseModelT]):
    def __init__(self, client: 'Client', model: Type[BaseModelT]) -> None:
        self._client = client
        self._model = model

    async def create(
        self,
        data: types.CategoryCreateInput,
        include: Optional[types.CategoryInclude] = None
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='Category',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='Category',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='Category',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='Category',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
    ) -> List[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='Category',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        include: Optional[types.CategoryInclude] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='Category',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.CategoryUpdateInput,
        where: types.CategoryWhereUniqueInput,
        include: Optional[types.CategoryInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='Category',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.CategoryWhereUniqueInput,
        data: types.CategoryUpsertInput,
        include: Optional[types.CategoryInclude] = None,
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='Category',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.CategoryUpdateManyMutationInput,
        where: types.CategoryWhereInput,
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='Category',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def count(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CategoryWhereInput] = None,
        cursor: Optional[types.CategoryWhereUniqueInput] = None,
        order: Optional[Union[types.CategoryOrderByInput, List[types.CategoryOrderByInput]]] = None,
    ) -> int:
        # TODO: support select
        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='Category',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
            },
            root_selection=['count { _all }'],
        )
        return cast(int, resp['data']['result']['count']['_all'])

    async def delete_many(
        self,
        where: Optional[types.CategoryWhereInput] = None
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='Category',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])


class ProfileActions(Generic[BaseModelT]):
    def __init__(self, client: 'Client', model: Type[BaseModelT]) -> None:
        self._client = client
        self._model = model

    async def create(
        self,
        data: types.ProfileCreateInput,
        include: Optional[types.ProfileInclude] = None
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='Profile',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProfileCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='Profile',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='Profile',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='Profile',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        include: Optional[types.ProfileInclude] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
    ) -> List[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='Profile',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        include: Optional[types.ProfileInclude] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='Profile',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.ProfileUpdateInput,
        where: types.ProfileWhereUniqueInput,
        include: Optional[types.ProfileInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='Profile',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.ProfileWhereUniqueInput,
        data: types.ProfileUpsertInput,
        include: Optional[types.ProfileInclude] = None,
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='Profile',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.ProfileUpdateManyMutationInput,
        where: types.ProfileWhereInput,
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='Profile',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def count(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProfileWhereInput] = None,
        cursor: Optional[types.ProfileWhereUniqueInput] = None,
        order: Optional[Union[types.ProfileOrderByInput, List[types.ProfileOrderByInput]]] = None,
    ) -> int:
        # TODO: support select
        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='Profile',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
            },
            root_selection=['count { _all }'],
        )
        return cast(int, resp['data']['result']['count']['_all'])

    async def delete_many(
        self,
        where: Optional[types.ProfileWhereInput] = None
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='Profile',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])


class TypesActions(Generic[BaseModelT]):
    def __init__(self, client: 'Client', model: Type[BaseModelT]) -> None:
        self._client = client
        self._model = model

    async def create(
        self,
        data: types.TypesCreateInput,
        include: Optional[types.TypesInclude] = None
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='createOne',
            model='Types',
            arguments={
                'data': data,
                'include': include,
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TypesCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = await self._client._execute(
            operation='mutation',
            method='createMany',
            model='Types',
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TypesWhereUniqueInput,
        include: Optional[types.TypesInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='deleteOne',
                model='Types',
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def find_unique(
        self,
        where: types.TypesWhereUniqueInput,
        include: Optional[types.TypesInclude] = None
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findUnique',
            model='Types',
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypesWhereInput] = None,
        cursor: Optional[types.TypesWhereUniqueInput] = None,
        include: Optional[types.TypesInclude] = None,
        order: Optional[Union[types.TypesOrderByInput, List[types.TypesOrderByInput]]] = None,
    ) -> List[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findMany',
            model='Types',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
            },
        )
        return [self._model.parse_obj(r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TypesWhereInput] = None,
        cursor: Optional[types.TypesWhereUniqueInput] = None,
        include: Optional[types.TypesInclude] = None,
        order: Optional[Union[types.TypesOrderByInput, List[types.TypesOrderByInput]]] = None,
    ) -> Optional[BaseModelT]:
        resp = await self._client._execute(
            operation='query',
            method='findFirst',
            model='Types',
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return self._model.parse_obj(result)

    async def update(
        self,
        data: types.TypesUpdateInput,
        where: types.TypesWhereUniqueInput,
        include: Optional[types.TypesInclude] = None
    ) -> Optional[BaseModelT]:
        try:
            resp = await self._client._execute(
                operation='mutation',
                method='updateOne',
                model='Types',
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return self._model.parse_obj(resp['data']['result'])

    async def upsert(
        self,
        where: types.TypesWhereUniqueInput,
        data: types.TypesUpsertInput,
        include: Optional[types.TypesInclude] = None,
    ) -> BaseModelT:
        resp = await self._client._execute(
            operation='mutation',
            method='upsertOne',
            model='Types',
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return self._model.parse_obj(resp['data']['result'])

    async def update_many(
        self,
        data: types.TypesUpdateManyMutationInput,
        where: types.TypesWhereInput,
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='updateMany',
            model='Types',
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def count(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TypesWhereInput] = None,
        cursor: Optional[types.TypesWhereUniqueInput] = None,
        order: Optional[Union[types.TypesOrderByInput, List[types.TypesOrderByInput]]] = None,
    ) -> int:
        # TODO: support select
        resp = await self._client._execute(
            operation='query',
            method='aggregate',
            model='Types',
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
            },
            root_selection=['count { _all }'],
        )
        return cast(int, resp['data']['result']['count']['_all'])

    async def delete_many(
        self,
        where: Optional[types.TypesWhereInput] = None
    ) -> int:
        resp = await self._client._execute(
            operation='mutation',
            method='deleteMany',
            model='Types',
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

