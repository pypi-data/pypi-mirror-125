import logging
from datazen import ROOT_NAMESPACE as ROOT_NAMESPACE
from datazen.classes.task_data_cache import TaskDataCache as TaskDataCache
from datazen.environment.base import Task as Task, TaskResult as TaskResult, dep_slug_unwrap as dep_slug_unwrap
from datazen.environment.manifest import set_output_dir as set_output_dir
from datazen.environment.manifest_cache import ManifestCacheEnvironment as ManifestCacheEnvironment
from datazen.parsing import merge as merge
from typing import Any, Callable, Dict, List, Optional, Tuple

LOG: Any
TaskFunction = Callable[..., TaskResult]

class TaskEnvironment(ManifestCacheEnvironment):
    def valid_noop(self, entry: dict, _: str, __: dict = ..., ___: List[str] = ..., logger: logging.Logger = ...) -> TaskResult: ...
    visited: Any
    is_new: Any
    default: str
    handles: Any
    data_cache: Any
    def __init__(self): ...
    def init_cache(self, cache_dir: str) -> None: ...
    def write_cache(self) -> None: ...
    def clean_cache(self, purge_data: bool = ...) -> None: ...
    @property
    def task_data(self) -> dict: ...
    def is_resolved(self, operation: str, target: str) -> bool: ...
    def is_task_new(self, operation: str, target: str) -> bool: ...
    def resolve(self, operation: str, target: str, should_cache: bool, is_new: bool) -> None: ...
    def push_dep(self, dep: str, task_stack: List[Task], curr_target: str) -> None: ...
    def get_dep_data(self, dep_list: List[str], logger: logging.Logger = ...) -> dict: ...
    def already_satisfied(self, target: str, output_path: Optional[str], load_deps: List[str], deps_changed: List[str] = ..., load_checks: Dict[str, List[str]] = ..., logger: logging.Logger = ...) -> bool: ...
    logger: Any
    def resolve_dependencies(self, dep_list: List[str], task_stack: List[Task], target: str, logger: logging.Logger = ...) -> Tuple[bool, dict, List[str]]: ...
    def get_manifest_entry(self, category: str, name: str) -> dict: ...
    def handle_task(self, key_name: str, target: str, task_stack: List[Task] = ..., should_cache: bool = ...) -> TaskResult: ...

def get_dep_list(entry: dict) -> List[str]: ...
def get_path(entry: dict, key: str = ...) -> str: ...
