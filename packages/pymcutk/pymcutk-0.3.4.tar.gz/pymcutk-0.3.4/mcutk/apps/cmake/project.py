#
# MIT License
#
# Copyright 2021 NXP
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#

import os
import re
import platform
import glob
import shutil

from mcutk.apps.projectbase import ProjectBase
from mcutk.exceptions import ProjectNotFound


BUILD_SYSTEMS = [
    {'name': 'ninja', 'generator': 'Ninja'},
    {'name': 'make', 'generator': 'Unix Makefiles'},
    {'name': 'mingw32-make', 'generator': 'MinGW Makefiles'}
]

def _get_build_tool(name):
    """Return a dict which contains generator info for cmake.
    If name is None this will automatically find available make tool.
    """
    if not name:
        for tool in BUILD_SYSTEMS:
            if shutil.which(tool['name']):
                return tool
    else:
        for tool in BUILD_SYSTEMS:
            if name == tool['name']:
                return tool

    raise RuntimeError("Cannot identify the build tool for CMake. Supported: %s" % str(BUILD_SYSTEMS))

def generate_build_cmdline(project, target, logfile, make_tool=None, workspace=None):
    """Generate and return the build command line for CMake + ninja/make/mingw32-make.
    Default it will try to find available make tool by the order: ninja, make, mingw32-make.

    Arguments:
        project {Project object} -- object of CMakeLists.
        target {str} -- configuration
        logfile {str} -- log file path.
        make_tool {str} -- could be ninja/make/mingw32-make, default is None.
        workspace {str} -- workspace used to store the files are generated by cmake.

    Returns:
        {str}
    """
    build_tool = _get_build_tool(make_tool)
    build_cmd = build_tool['name']
    cmake_generator = build_tool['generator']

    if not workspace:
        build_dir = project.prjdir
    else:
        build_dir = workspace
        if os.path.exists(build_dir):
            shutil.rmtree(build_dir)

    osname = platform.system()
    if osname == "Windows":
        suffix = 'bat'
        exit_cmd = "exit /b %errorlevel%"
    else:
        suffix = 'sh'
        exit_cmd = "exit $?"

    exe_cmd = 'cmake -B {build_dir} -Wno-deprecated -DCMAKE_TOOLCHAIN_FILE={toolchain_cmake} -G "{cmake_generator}" '\
    '-DCMAKE_BUILD_TYPE={build_type} {source_dir} && {build_cmd} -C {build_dir} -j 10'.format(
        build_dir=build_dir, toolchain_cmake=project.toolchain_file,
        cmake_generator=cmake_generator, build_type=target,
        source_dir=project.prjdir, build_cmd=build_cmd
    )

    script_file = os.path.join(project.prjdir, "mtk_build.{}".format(suffix)).replace('\\', '/')
    script_file = os.path.abspath(script_file)
    with open(script_file, 'w+') as fobj:
        fobj.write(exe_cmd + os.linesep)
        fobj.write(exit_cmd + os.linesep)

    os.chmod(script_file, 0o777)

    if logfile:
        script_file = "\"{}\" > {} 2>&1".format(script_file, logfile)

    return script_file



class Project(ProjectBase):
    """ Wraps a project defined in CMakeLists.txt."""

    PROJECT_EXTENSION = 'CMakeLists.txt'

    @classmethod
    def frompath(cls, path):
        """Return a project instance from a given file path or directory.

        If path is a directory, it will search the project file and return an instance.
        Else this will raise mcutk.apps.exceptions.ProjectNotFound.
        """

        if os.path.isfile(path) and path.endswith(cls.PROJECT_EXTENSION):
            return cls(path)

        if glob.glob(path + "/CMakeLists.txt") and glob.glob(path + "/build_all.*"):
            return cls(path + "/CMakeLists.txt")

        raise ProjectNotFound("Not found CMake project in path: %s"%path)

    def __init__(self, path, *args, **kwargs):
        super(Project, self).__init__(path, **kwargs)
        self._name = None
        self._targets = None
        self._toolchain_file = self.get_toolchain_file()
        self._conf = self._parse_project()

    def _parse_project(self):
        """Parse configurations from CMakeLists.txt.

        Returns:
            dict -- targets configuration
        """
        with open(self.prjpath, 'r') as fh:
            content = fh.read()

        # extract output name
        output_keywords = [
            r'add_library\([\w\-]+(\.)?\w+',
            r'add_executable\([\w\-]+(\.)?\w+',
            r'set_target_properties\(\w+(\.)?\w+',
            r'TARGET_LINK_LIBRARIES\(.*\.?\w+'
        ]

        excutable = None

        # since, release13, variable MCUX_SDK_PROJECT_NAME store the
        # executable configuration, example:
        # set(MCUX_SDK_PROJECT_NAME glow_cifar10.elf)
        match = re.compile("set\(MCUX_SDK_PROJECT_NAME (.*)\)").search(content)
        if match is not None:
            excutable = match.group(1)

        # compatible with old style
        if not excutable:
            for keyword in output_keywords:
                match = re.compile(keyword).search(content)
                if match != None:
                    excutable = match.group(0).split('(')[1].strip()
                    break

        # raise exception if there still not found
        if not excutable:
            raise ValueError("Unable to detect output definition in CMakeLists.txt. [%s]" % \
                             self.prjpath)

        self._appname = excutable.split('.')[0]

        if not self._targets:
            target_keyword = "CMAKE_C_FLAGS_"
            targets_list = re.findall(r"{}\w+ ".format(target_keyword), content)
            if not targets_list:
                target_keyword = "CMAKE_EXE_LINKER_FLAGS_"
                targets_list = re.findall(r"{}\w+ ".format(target_keyword), content)
            self._targets = [m.replace(target_keyword, '').lower().strip() for m in targets_list]

        # Add for vglite_acceptance, get extra path from EXECUTABLE_OUTPUT_PATH settings.
        extra_path = ""
        match = re.compile(r"SET\(EXECUTABLE_OUTPUT_PATH\s+\$\{ProjDirPath\}\/(.*)\/\$\{CMAKE_BUILD_TYPE\}\)", re.I).search(content)
        if match is not None:
            extra_path = match.group(1)

        # extract build types
        configs = dict()
        for tname in self._targets:
            if tname not in configs:
                if extra_path:
                    configs[tname] = "{}/{}/{}".format(extra_path, tname, excutable)
                else:
                    configs[tname] = "{}/{}".format(tname, excutable)
        return configs

    def get_toolchain_file(self):
        """This is a workaround to find the cmake toolchain file."""

        try:
            script_file = glob.glob(os.path.dirname(self.prjpath) + "/build_all.*")[0]
        except Exception:
            raise IOError("Unable to indentify CMAKE_TOOLCHAIN_FILE! "\
                          "Because script(build_all.sh/.bat) is not found!")

        with open(script_file, "r") as fobj:
            filecontent = fobj.read()

        toolchain_file = ''
        toolchain_ptn = re.compile(r'-DCMAKE_TOOLCHAIN_FILE="(\S+)" ')
        build_type_ptn = re.compile(r'-DCMAKE_BUILD_TYPE=(\S+) ')
        build_type_target_ptn = re.compile(r'build_(\w+)\.sh')

        match = toolchain_ptn.search(filecontent)
        if match:
            toolchain_file = match.group(1)

        # try to list configurations from shell script
        if not self._targets:
            self._targets = list(set(build_type_ptn.findall(filecontent)))

        # try to list configurations from shell script for vglite_acceptance
        if not self._targets:
            self._targets = list(set(build_type_target_ptn.findall(filecontent)))

        if toolchain_file:
            return toolchain_file

        # a work around to find toolchain file from parent folder
        # assum the toolchian is armgcc
        toolchain_file = _search_from_local(self.prjdir)
        if not toolchain_file:
            raise ValueError("not found toolchain file! project: %s" % self.prjpath)
        else:
            return toolchain_file

    @property
    def name(self):
        """Return application name"""
        return self._appname

    @property
    def toolchain_file(self):
        """Return a relative path for cmake_toolchain_file."""
        return self._toolchain_file

    @property
    def idename(self):
        """Return the toolchain name that the cmake defined."""
        if self.toolchain_file:
            filename = os.path.basename(self.toolchain_file)
            return filename.replace(".cmake", '').strip()
        return 'cmake'


def _search_from_local(path):
    current_dir = path
    while True:
        parent_dir = os.path.dirname(os.path.abspath(current_dir))
        # system root
        if parent_dir == current_dir:
            break
        _file = os.path.join(parent_dir, "tools/cmake_toolchain_files/armgcc.cmake")
        current_dir = parent_dir
        if os.path.exists(_file):
            return _file
    return ""
