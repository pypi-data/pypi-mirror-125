{"version":3,"file":"lib_index_js.9c2516db3c9ee0b235b2.js","mappings":";;;;;;;;;;;;;;;;;;AAAyC;AACC;AACnC;AACP,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA,2BAA2B,yDAAU;AACrC;AACA,iCAAiC;AACjC;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,oDAAoD;AAChG,qCAAqC;AACrC,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,iBAAiB;AACjB;AACA;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA,8CAA8C;AAC9C,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,0EAA0E,eAAe;AACzF;AACA;AACA;AACA;AACO,gDAAgD,oDAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://@educational-technology-collective/etc_jupyterlab_notebook_state_provider/./lib/index.js"],"sourcesContent":["import { UUID } from \"@lumino/coreutils\";\nimport { Token } from '@lumino/coreutils';\nexport class ETCJupyterLabNotebookState {\n    constructor({ notebookPanel }) {\n        var _a;\n        this._notebook = notebookPanel.content;\n        this._cellState = new WeakMap();\n        this._seq = 0;\n        this._session_id = UUID.uuid4();\n        this.updateCellState();\n        //  The notebook loaded; hence, update the cell state.\n        (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect((sender, args) => {\n            if (args.type == \"add\" || args.type == \"set\") {\n                this.updateCellState();\n                //  A cell was added; hence, update the cell state.\n            }\n        }, this);\n    }\n    updateCellState() {\n        this._notebook.widgets.forEach((cell) => {\n            if (!this._cellState.has(cell)) {\n                this._cellState.set(cell, { changed: true, output: this.createCellOutput(cell) });\n                //  It's a new cell; hence, the changed state is set to true.\n                ////  This is a new cell; hence, add handlers that check for changes in the inputs and outputs.\n                cell.inputArea.model.value.changed.connect((sender, args) => {\n                    let state = this._cellState.get(cell);\n                    if (state !== undefined) {\n                        state.changed = true;\n                        //  The input area changed; hence, the changed state is set to true.\n                    }\n                });\n                if (cell.model.type == \"code\") {\n                    cell.model.outputs.changed.connect((sender, args) => {\n                        if (args.type == \"add\") {\n                            //  An output has been added to the cell; hence, compare the current state with the new state.\n                            let state = this._cellState.get(cell);\n                            if (state !== undefined) {\n                                let output = this.createCellOutput(cell);\n                                if (output !== (state === null || state === void 0 ? void 0 : state.output)) {\n                                    //  The output has changed; hence, set changed to true and update the output state.\n                                    state.changed = true;\n                                    state.output = output;\n                                }\n                                else {\n                                    //  The output hasn't changed; hence, leave the state as is.\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createCellOutput(cell) {\n        //  Combine the cell outputs into a string in order to check for changes.\n        let output = \"\";\n        if (cell.model.type == \"code\") {\n            let outputs = cell.model.outputs;\n            for (let index = 0; index < outputs.length; index++) {\n                for (let key of Object.keys(outputs.get(index).data).sort()) {\n                    output = output + JSON.stringify(outputs.get(index).data[key]);\n                }\n            }\n            return output;\n        }\n        return \"\";\n    }\n    getNotebookState() {\n        var _a;\n        let nbFormatNotebook = (_a = this._notebook.model) === null || _a === void 0 ? void 0 : _a.toJSON();\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState === undefined) {\n                throw new Error(`The cell at index ${index} is not tracked.`);\n            }\n            if (cellState.changed === false) {\n                //  The cell has not changed; hence, the notebook format cell will contain just its id.\n                nbFormatNotebook.cells[index] = { id: this._notebook.widgets[index].model.id };\n            }\n            else {\n                nbFormatNotebook.cells[index]['id'] = this._notebook.widgets[index].model.id;\n            }\n        }\n        for (let index = 0; index < this._notebook.widgets.length; index++) {\n            let cell = this._notebook.widgets[index];\n            let cellState = this._cellState.get(cell);\n            if (cellState !== undefined) {\n                cellState.changed = false;\n            }\n            //  The cell state is going to be captured; hence, set the state to not changed.\n            //  We need to be certain that all the cells were processed prior to making any changes to their state;\n            //  hence, this operation is done in a loop separate from the loop above.\n        }\n        let state = {\n            session_id: this._session_id,\n            seq: this._seq,\n            notebook: nbFormatNotebook\n        };\n        this._seq = this._seq + 1;\n        //  We've made changes to the state at this point; \n        //  hence, it's really important that nothing throws between now and recording the message.\n        //  We need all the messages in order to reconstruct the Notebook at each event;\n        //  hence, we need all the messages in order to reconstruct the Notebook at each event. :-)\n        return state;\n    }\n}\nexport class ETCJupyterLabNotebookStateProvider {\n    constructor() {\n        this._notebookPanelMap = new WeakMap();\n    }\n    getNotebookState({ notebookPanel }) {\n        let notebookState = this._notebookPanelMap.get(notebookPanel);\n        return notebookState === null || notebookState === void 0 ? void 0 : notebookState.getNotebookState();\n    }\n    addNotebookPanel({ notebookPanel }) {\n        let etcJupyterLabNotebookState = new ETCJupyterLabNotebookState({ notebookPanel });\n        this._notebookPanelMap.set(notebookPanel, etcJupyterLabNotebookState);\n    }\n}\nconst PLUGIN_ID = \"@educational-technology-collective/etc_jupyterlab_notebook_state_provider:plugin\";\nexport const IETCJupyterLabNotebookStateProvider = new Token(PLUGIN_ID);\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_notebook_state extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IETCJupyterLabNotebookStateProvider,\n    activate: (app) => {\n        console.log(`The JupyterLab plugin ${PLUGIN_ID} is activated!`);\n        return new ETCJupyterLabNotebookStateProvider();\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}