# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['fungi']

package_data = \
{'': ['*']}

install_requires = \
['inotify-simple>=1.3.5,<2.0.0',
 'psutil>=5.8.0,<6.0.0',
 'typeguard>=2.1.0,<3.0.0']

setup_kwargs = {
    'name': 'fungi',
    'version': '0.1.0',
    'description': 'A set of common utilities for iNotify (based on iNotify Simple) that makes it a little easier to work with',
    'long_description': '# Fungi\n\nA set of common utilities for iNotify that allows developers to keep track of file changes even when their application is not running.\n\n## Usage\n\nThis library is designed as an easy way to work with iNotify for the purposes of tracking file changes. It is built on top of [`inotify-simple`](https://inotify-simple.readthedocs.io/en/latest/#) which is already excellent and makes some things a LOT easier, but this library tacks on some functionality, such as the ability to react to file changes that occur when the application is not running as well as the ability to deal with changes that iNotify does not pick up for whatever reason.\n\nThe basic means of using it is something like this:\n\n```python\nfrom pathlib import Path\nfrom fungi import SQLiteMonitor, MODIFIED_OR_DELETED\n\nfor changed in SQLiteMonitor(Path.home() / \'.config\' / \'my-app-file-tracking.db\',\n                             MODIFIED_OR_DELETED,\n                             [Path.cwd()]).read(timeout=1000, read_delay=100):\n    print(changed)\n```\n\nSo what\'s happening here? Well, we instantiate a [`SQLiteMonitor`](https://gitlab.com/abraxos/fungi/-/blob/main/fungi/core.py#L146), which uses a [SQLite Database](https://www.sqlite.org/index.html) to keep track of files and when they\'ve been modified. In our example, this database would live in `~/.config/my-app-file-tracking.db`. On top of this, we have the `MODIFIED_OR_DELETED` flag, which is just a variable representing several flags used by `inotify-simple`. [You can see all the accepted flag inputs here](https://inotify-simple.readthedocs.io/en/latest/#inotify_simple.flags), [as well as how to use them](https://inotify-simple.readthedocs.io/en/latest/#example-usage). Then we have a list of paths to watch (which can be either directories or individual files), and finally we have the `timeout` which is how often (in milliseconds) it polls for changes that might not have been tracked for whatever reason, [and the `read_delay`](https://inotify-simple.readthedocs.io/en/latest/#inotify_simple.INotify.read).\n\nWhile the `SQLiteMonitor` uses a SQLite DB file to keep track of files, there are other options. For example, [`SymlinkMonitor`](https://gitlab.com/abraxos/fungi/-/blob/main/fungi/core.py#L191) takes a directory, where it keeps symlinks of tracked files and uses this to keep track of when files were modified. There is also a [`MemoryMonitor`](https://gitlab.com/abraxos/fungi/-/blob/main/fungi/core.py#L123) which only keeps information in memory, and the most basic [`Monitor`](https://gitlab.com/abraxos/fungi/-/blob/main/fungi/core.py#L22) which is just a thin wrapper iNotify observer. Note that `Monitor` and `MemoryMonitor` cannot keep track of files that change when they\'re not running, you have to use either `SymlinkMonitor` or `SQLiteMonitor`. One might ask, why bother with a `SymlinkMonitor`? What\'s the advantage? Isn\'t it considerably slower than SQLite? and the answer is that yes it is, however, the `SymlinkMonitor` allows you to see the symlinks in the file system as they are being tracked and even change them if you want to, easer than in a SQLite DB.\n\nArguably the coolest part of this is what happens when you *stop* the script. Try it for yourself, stop it, make some changes, and then run the script again. You will notice that it prints out the modified files even though the script was not running!\n\n## Installation & Setup\n\nTo install fungi with [`pip`](https://pip.pypa.io/en/stable/) execute the following:\n\n```bash\npip install fungi\n```\n\nIf you don\'t want to re-install every time there is an update, and prefer to just pull from the git repository (see ***Development Setup*** section), then use the `-e` flag:\n\n```bash\npip install -e /path/to/repo\n```\n\n## Development\n\n### Standards\n\n- Be excellent to each other\n- Code coverage must be at 100% for all new code, or a good reason must be provided for why a given bit of code is not covered.\n  - Example of an acceptable reason: "There is a bug in the code coverage tool and it says its missing this, but its not".\n  - Example of unacceptable reason: "This is just exception handling, its too annoying to cover it".\n- The code must pass the following analytics tools. Similar exceptions are allowable as in rule 2.\n  - `pylint --disable=C0111,W1203,R0903 --max-line-length=100 ...`\n  - `flake8 --max-line-length=100 ...`\n  - `mypy --ignore-missing-imports --follow-imports=skip --strict-optional ...`\n- All incoming information from users, clients, and configurations should be validated.\n- All internal arguments passing should be typechecked whenever possible with `typeguard.typechecked`\n\n### Development Setup\n\nUsing [poetry](https://python-poetry.org/) install from inside the repo directory:\n\n```bash\npoetry install\n```\n\nThis will set up a virtualenv which you can always activate with either `poetry shell` or run specific commands with `poetry run`. All instructions below that are meant to be run in the virtualenv will be prefaced with `(fungi)$ `\n\n#### IDE Setup\n\n**Sublime Text 3**\n\n```bash\ncurl -sSL https://gitlab.com/-/snippets/2066312/raw/master/poetry.sublime-project.py | poetry run python\n```\n\n## Testing\n\nAll testing should be done with `pytest` which is installed with the `dev` requirements.\n\nTo run all the unit tests, execute the following from the repo directory:\n\n```bash\n(fungi)$ pytest\n```\n\nThis should produce a coverage report in `/path/to/dewey-api/htmlcov/`\n\nWhile developing, you can use [`watchexec`](https://github.com/watchexec/watchexec) to monitor the file system for changes and re-run the tests:\n\n```bash\n(fungi)$ watchexec -r -e py,yaml pytest\n```\n\nTo run a specific test file:\n\n```bash\npytest tests/unit/test_core.py\n```\n\nTo run a specific test:\n\n```bash\npytest tests/unit/test_core.py::test_basic_inotify\n```\n\nFor more information on testing, see the `pytest.ini` file as well as the [documentation](https://docs.pytest.org/en/stable/).\n',
    'author': 'Eugene Kovalev',
    'author_email': 'eugene@kovalev.systems',
    'maintainer': None,
    'maintainer_email': None,
    'url': 'https://gitlab.com/abraxos/fungi',
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'python_requires': '>=3.6,<4.0',
}


setup(**setup_kwargs)
