# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/03_model.ipynb (unless otherwise specified).

__all__ = [
    "suggest_control",
    "extract_date_indexes",
    "pivot_markets_campaigns",
    "time_periods",
    "normalize_data",
    "causal_impact_correlation",
    "simulate_uplift",
    "main",
]

# Cell
from itertools import permutations
from typing import List, Optional, Tuple

import pandas as pd
from causalimpact import CausalImpact


def suggest_control(
    df=pd.DataFrame(),
    start_date=str(),
    start_intervention=str(),
    end_date=str(),
    control_col=str(),
):

    """This functions evaluates all the possible combinations of potentials control time serieses"""
    all_combinations = []

    # Create all combinations
    for i in range(1, len(control_col)):
        for j in list(permutations(control_col, i)):
            all_combinations.append(list(j))
    all_combinations.append(list(control_col))

    # Intialize relative effect
    rel_effect = pd.DataFrame()

    # Apply model to non-itervention period
    for all_c in all_combinations:

        # Extract pre and post periods
        temp_start_intervention = (
            pd.to_datetime(start_intervention) + pd.DateOffset(days=-6)
        ).strftime("%Y-%m-%d")
        temp_end_date = (
            pd.to_datetime(start_intervention) + pd.DateOffset(days=-1)
        ).strftime("%Y-%m-%d")

        pre_period, post_period = extract_date_indexes(
            df=df,
            start_date=start_date,
            start_intervention=temp_start_intervention,
            end_date=temp_end_date,
        )

        # Select columns and period
        train_df = df[["y"] + all_c].reset_index(drop=True)

        # Extract the relative effect
        ci = CausalImpact(train_df, pre_period, post_period)
        data1 = {
            "control_ts": all_c,
            "cumulative_relative_effect": ci.summary_data["cumulative"]["rel_effect"],
        }
        rel_effect = rel_effect.append(data1, ignore_index=True)

    return rel_effect


def extract_date_indexes(
    df=pd.DataFrame(), start_date=str(), start_intervention=str(), end_date=str()
):

    """This functions extracts the indexes"""
    end_of_pre_period = (
        pd.to_datetime(start_intervention) + pd.DateOffset(days=-1)
    ).strftime("%Y-%m-%d")

    pre_period = [
        list(df["date"]).index(start_date),
        list(df["date"]).index(end_of_pre_period),
    ]
    post_period = [
        list(df["date"]).index(start_intervention),
        list(df["date"]).index(end_date),
    ]

    return (pre_period, post_period)


def pivot_markets_campaigns(
    df=pd.DataFrame(), country_campaign="country_campaign", target="y"
) -> pd.DataFrame:
    """Funtion to pivot the table when it has many groups which will serve as target and campaigns/markets to compare with

    Args:
        df (DataFrame): DataFrame acquired from BigQuery with the target feature and all the different markets/campaigns
        country_campaign (str, optional): Name of the column containing all of the groups. Defaults to "country_campaign".
        target (str, optional): [description]. Defaults to "y". Can enter list of multiple columns if needed

    Returns:
        DataFrame: Pivoted dataframe ready for correlation analysis & counterfactual analysis
    """

    df["date"] = pd.to_datetime(df["date"])
    df_pivot = (
        # Seperate target into another list so that user can enter multiple target columns if required (e.g. cvr & revenue)
        df.reset_index()[[country_campaign, "date"] + [target]]
        .pivot(index="date", columns=country_campaign, values=target)
        .fillna(0)
    )

    return df_pivot


def time_periods(
    df: pd.DataFrame,
    start_intervention: str,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
) -> Tuple[List, List]:
    """Function to define the time pre and post intervention periods for Causal Impact purposes

    Args:
        df (DataFrame): The pivoted dataframe with date as index, the start date can be acquired here (in case the start date in the query was too early)
        start_intervention (str): The date on which the intervention was done
        start_date (str, optional): The start date of the time series to use for correlation & training purposes
        end_date (str, optional): The end date of the intervention

    Returns:
        pre_period (List): The period before intervention
        post_period (List): The period after intervention
    """

    if not start_date:
        pre_period = [
            pd.to_datetime(start_intervention) - pd.DateOffset(days=1, months=6),
            pd.to_datetime(start_intervention) - pd.DateOffset(1),
        ]
    else:
        pre_period = [start_date, pd.to_datetime(start_intervention) - pd.DateOffset(1)]

    # Check if the startdate is lower than the first index entry, if so then take the index date as startdate
    # if pre_period[0] < pd.to_datetime(df.index.min()):
    #     pre_period = [df.index.min(), pd.to_datetime(start_intervention) - pd.DateOffset(1)]

    # Check if end date is defined, if so then take that as end date instead of the predefined 1 months increase
    if end_date:
        post_period = [pd.to_datetime(date) for date in [start_intervention, end_date]]
    else:
        post_period = [
            pd.to_datetime(date)
            for date in [
                start_intervention,
                pd.to_datetime(start_intervention) + pd.DateOffset(months=1),
            ]
        ]

    return (pre_period, post_period)


def normalize_data(df, technique="std"):
    if technique == "std":
        df_normalized = (df - df.mean()) / df.std()

    else:
        df_normalized = (df - df.min()) / (df.max() - df.min())

    return df_normalized


def causal_impact_correlation(
    df: pd.DataFrame, pre_period: List, target
) -> pd.DataFrame:
    """Function to identify the top 5 correlated features with our target feature

    Args:
        df (DataFrame): DataFrame which is a matrix of the metric to measure for, every column being the feature (and target)
        pre_period (List): List containing the start and end of the pre-treatment period
        target (str): The target column

    Returns:
        DataFrame: DataFrame with the target variable and the top 5 covariates to be used for counterfactual analysis
    """
    filt_df = df[df.index >= pre_period[0]]

    corr_matrix = filt_df[filt_df.index <= pre_period[1]].corr()
    target_col = corr_matrix[target]
    target_features = target_col.nlargest(6).index.values

    print(
        f"In the pearson correlation, the following features correlate strongest with target {target}:"
    )
    print(corr_matrix[target].nlargest(6))

    causal_df = df[target_features]
    return causal_df


def simulate_uplift(df: pd.DataFrame, pre_period: List, uplift: int) -> pd.DataFrame:
    """Function to add simulate synthetic uplift to test sensitivity of the model

    Args:
        df (DataFrame): The dataframe with the target and features. Target variable has to be the first column, which is the case if ran after causal_impact_correlation()
        pre_period (List): The period before (simulated) treatment, so that synthetic uplift can be applied to everything after the pre-treatment
        uplift (int): The synthetic uplift to introduce

    Returns:
        DataFrame: copy of the dataframe with synthetic uplift introduced for simulation purposes
    """
    # Add simulated uplift to the post-period. Use a copy because we don't want to overwrite the original dataframe
    df_copy = df.copy()
    df_copy.iloc[:, 0].loc[df_copy.index > pre_period[-1]] = (
        df_copy.iloc[:, 0].loc[df_copy.index > pre_period[-1]] * uplift
    )

    return df_copy


def main(
    df: pd.DataFrame,
    start_intervention: str,
    target_feature: str,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    normalize: Optional[bool] = False,
    normalize_technique: Optional[str] = "minmax",
    uplift: int = 1,
    fit_method: str = "vi",
):
    """Function to prepare the data for counterfactuals and run the causal impact model. Can introduce uplift if needed

    Args:
        df (DataFrame): DataFrame which is a matrix of the metric to measure for, every column being the feature (and target)
        start_intervention (str): The date on which the intervention was done
        target_feature (str): The treatment group. The remaining groups will checked for correlation with treatment group
        start_date (str, Optional): The start date of the training period. If empty, model will take 6 months before intervention
        end_date (str, Optional): The end date of the intervention period. If empty, model will take 1 month after intervention
        normalize (bool, Optional): Whether to normalize the data. If empty, does not normalize.
        normalize_technique (str, Optional): Method to use for normalization. If nothing, chooses minmax, for std enter 'std'
        uplift (int, Optional): The uplift that should be introduced to the data. If empty, no uplift will be done
        fit_method (str): The method to use for causal impact. Default is 'vi'. Slower but more accurate alternative is 'hmc'

    Returns:
        Object: Causal impact model: Run ci.plot() for plot, and ci.summary() for statistics
    """

    pre_period, post_period = time_periods(df, start_intervention, start_date, end_date)

    df = causal_impact_correlation(df, pre_period, target_feature)

    if uplift != 1:
        df = simulate_uplift(df, pre_period, uplift)

    if normalize:
        df = normalize_data(df, technique=normalize_technique)

    ci = CausalImpact(
        df, pre_period, post_period, model_args={"fit_method": fit_method}
    )

    return ci
